<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>eta.util.tt.match &mdash; eta-py 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=af2ce170"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="eta.util.tt.match.check_position_index_syntax" href="eta.util.tt.match.check_position_index_syntax.html" />
    <link rel="prev" title="eta.util.tt.choice.is_tree_root_list" href="eta.util.tt.choice.is_tree_root_list.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            eta-py
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home page</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="eta.html">Eta documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="eta.config.html">eta.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.constants.html">eta.constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.core.html">eta.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.discourse.html">eta.discourse</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.embedding.html">eta.embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.lf.html">eta.lf</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.memory.html">eta.memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.plan.html">eta.plan</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.schema.html">eta.schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="eta.transducers.html">eta.transducers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="eta.util.html">eta.util</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="eta.util.buffer.html">eta.util.buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="eta.util.file.html">eta.util.file</a></li>
<li class="toctree-l3"><a class="reference internal" href="eta.util.general.html">eta.util.general</a></li>
<li class="toctree-l3"><a class="reference internal" href="eta.util.gpt.html">eta.util.gpt</a></li>
<li class="toctree-l3"><a class="reference internal" href="eta.util.sexpr.html">eta.util.sexpr</a></li>
<li class="toctree-l3"><a class="reference internal" href="eta.util.time.html">eta.util.time</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="eta.util.tt.html">eta.util.tt</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="eta.util.tt.choice.html">eta.util.tt.choice</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">eta.util.tt.match</a></li>
<li class="toctree-l4"><a class="reference internal" href="eta.util.tt.parse.html">eta.util.tt.parse</a></li>
<li class="toctree-l4"><a class="reference internal" href="eta.util.tt.preds.html">eta.util.tt.preds</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="eta.util.ulf.html">eta.util.ulf</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">eta-py</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="eta.html">eta</a></li>
          <li class="breadcrumb-item"><a href="eta.util.html">eta.util</a></li>
          <li class="breadcrumb-item"><a href="eta.util.tt.html">eta.util.tt</a></li>
      <li class="breadcrumb-item active">eta.util.tt.match</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-eta.util.tt.match">
<span id="eta-util-tt-match"></span><h1>eta.util.tt.match<a class="headerlink" href="#module-eta.util.tt.match" title="Permalink to this heading"></a></h1>
<p>Methods for matching a TT pattern to an S-expression and filling in a corresponding template.</p>
<p>Contains a Python reimplementation of the original LISP tree transduction (TT) functions
defined here: <a class="reference external" href="https://github.com/bkane2/eta/tree/master/core/tt">https://github.com/bkane2/eta/tree/master/core/tt</a></p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.check_position_index_syntax.html#eta.util.tt.match.check_position_index_syntax" title="eta.util.tt.match.check_position_index_syntax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_position_index_syntax</span></code></a></p></td>
<td><p>Check if <cite>i</cite> is a valid position index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.dec_num_var.html#eta.util.tt.match.dec_num_var" title="eta.util.tt.match.dec_num_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dec_num_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.dot_atom.html#eta.util.tt.match.dot_atom" title="eta.util.tt.match.dot_atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot_atom</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.e_var.html#eta.util.tt.match.e_var" title="eta.util.tt.match.e_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">e_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.fill_template.html#eta.util.tt.match.fill_template" title="eta.util.tt.match.fill_template"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_template</span></code></a></p></td>
<td><p>Fill a template containing positional indices with constituents from a match result.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.flatten_sequences.html#eta.util.tt.match.flatten_sequences" title="eta.util.tt.match.flatten_sequences"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten_sequences</span></code></a></p></td>
<td><p>Flatten lists marked as sequences, i.e., of the form <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">...]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.hard_atom.html#eta.util.tt.match.hard_atom" title="eta.util.tt.match.hard_atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hard_atom</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.indexed_element_of.html#eta.util.tt.match.indexed_element_of" title="eta.util.tt.match.indexed_element_of"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indexed_element_of</span></code></a></p></td>
<td><p>Obtains the element of an expression located at a nested index (an integer or list of integers).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.isa.html#eta.util.tt.match.isa" title="eta.util.tt.match.isa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isa</span></code></a></p></td>
<td><p>Determine whether a given word has a given feature.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.match.html#eta.util.tt.match.match" title="eta.util.tt.match.match"><code class="xref py py-obj docutils literal notranslate"><span class="pre">match</span></code></a></p></td>
<td><p>Match a given pattern S-expression to an input S-expression.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.match_var.html#eta.util.tt.match.match_var" title="eta.util.tt.match.match_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">match_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.num_var.html#eta.util.tt.match.num_var" title="eta.util.tt.match.num_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.ok.html#eta.util.tt.match.ok" title="eta.util.tt.match.ok"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ok</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.p_var.html#eta.util.tt.match.p_var" title="eta.util.tt.match.p_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">p_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.position_index.html#eta.util.tt.match.position_index" title="eta.util.tt.match.position_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position_index</span></code></a></p></td>
<td><p>Map a string denoting a position index to either an integer or list of integers (or return <code class="docutils literal notranslate"><span class="pre">[]</span></code> if not a position index).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.pred_var_any.html#eta.util.tt.match.pred_var_any" title="eta.util.tt.match.pred_var_any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pred_var_any</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.q_var.html#eta.util.tt.match.q_var" title="eta.util.tt.match.q_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">q_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.s_var.html#eta.util.tt.match.s_var" title="eta.util.tt.match.s_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">s_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.s_variant_of_p_var.html#eta.util.tt.match.s_variant_of_p_var" title="eta.util.tt.match.s_variant_of_p_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">s_variant_of_p_var</span></code></a></p></td>
<td><p>Return the <a href="#id1"><span class="problematic" id="id2">*</span></a>-variant of the given +-var.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.seq_var.html#eta.util.tt.match.seq_var" title="eta.util.tt.match.seq_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">seq_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.soft_var.html#eta.util.tt.match.soft_var" title="eta.util.tt.match.soft_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">soft_var</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.spec_function.html#eta.util.tt.match.spec_function" title="eta.util.tt.match.spec_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spec_function</span></code></a></p></td>
<td><p>Check if <cite>x</cite> is a user-defined evaluable function, i.e., if it ends with '!'.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="eta.util.tt.match.underlying_feat.html#eta.util.tt.match.underlying_feat" title="eta.util.tt.match.underlying_feat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">underlying_feat</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="eta.util.tt.match.val.html#eta.util.tt.match.val" title="eta.util.tt.match.val"><code class="xref py py-obj docutils literal notranslate"><span class="pre">val</span></code></a></p></td>
<td><p>Determine whether a predicate is true of a given expression.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.flatten_sequences">
<span class="sig-name descname"><span class="pre">flatten_sequences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#flatten_sequences"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.flatten_sequences" title="Permalink to this definition"></a></dt>
<dd><p>Flatten lists marked as sequences, i.e., of the form <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">...]</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">...]</span></code> expressions are not allowed to contain such expressions as sequence elements (i.e., these
would not be flattened. It would be easy to allow them, but for the pattern transductions here no such
embeddings occur, because sequence expressions are match-values of single sequence variables, like <a href="#id3"><span class="problematic" id="id4">*</span></a>atom
or +expr, and these are matched only against input expressions free of sequence expressions.)</p>
<p>A top-level expr like <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">a]</span></code> or <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">[]]</span></code> or <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">[a,</span> <span class="pre">b]]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code>, or <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b]</span></code> respectively,
i.e., a 1-element sequence is turned into that one element. However, an empty sequence <code class="docutils literal notranslate"><span class="pre">[:seq]</span></code> or longer
sequence like <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">a,</span> <span class="pre">b]</span></code> is left unchanged, since removing <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">...]</span></code> doesn’t leave a single valid expression.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.indexed_element_of">
<span class="sig-name descname"><span class="pre">indexed_element_of</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#indexed_element_of"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.indexed_element_of" title="Permalink to this definition"></a></dt>
<dd><p>Obtains the element of an expression located at a nested index (an integer or list of integers).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.s_variant_of_p_var">
<span class="sig-name descname"><span class="pre">s_variant_of_p_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_var</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#s_variant_of_p_var"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.s_variant_of_p_var" title="Permalink to this definition"></a></dt>
<dd><p>Return the <a href="#id5"><span class="problematic" id="id6">*</span></a>-variant of the given +-var.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.val">
<span class="sig-name descname"><span class="pre">val</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#val"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.val" title="Permalink to this definition"></a></dt>
<dd><p>Determine whether a predicate is true of a given expression.</p>
<p>If <cite>var</cite> is a multi-character atom starting with ‘!’, then it’s expected
to have a function definition corresponding to the string following the ‘!’.
If it starts with ?/<a href="#id7"><span class="problematic" id="id8">*</span></a>/+ then the corresponding !-predicate must be obtained
through string manipulation. If <cite>var</cite> is a nonnegative integer then the
corresponding predicate is !expr, which is true of any expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – Either a non-negative integer or a match variable with {!,?,*,+} as a prefix.</p></li>
<li><p><strong>expr</strong> (<em>s-expr</em>) – An S-expression to check.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.isa">
<span class="sig-name descname"><span class="pre">isa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#isa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.isa" title="Permalink to this definition"></a></dt>
<dd><p>Determine whether a given word has a given feature.</p>
<p>NB: an atom is always assumed to have itself as a feature. If this is
not desired, define it as a custom !predicate rather than a feature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – A word (e.g., <code class="docutils literal notranslate"><span class="pre">surgeon</span></code> or <code class="docutils literal notranslate"><span class="pre">doctor</span></code>).</p></li>
<li><p><strong>feat</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – A feature string (e.g., <code class="docutils literal notranslate"><span class="pre">professional</span></code>).</p></li>
<li><p><strong>feats</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a>) – A dict mapping words to feature lists.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#match"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.match" title="Permalink to this definition"></a></dt>
<dd><p>Match a given pattern S-expression to an input S-expression.</p>
<p>:nil results from match_rec are mapped to an empty list, under the assumption
that the <code class="docutils literal notranslate"><span class="pre">match_rec([],</span> <span class="pre">[])</span></code> case is unnecessary for Eta rule trees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pa</strong> (<em>s-expr</em>) – <dl class="simple">
<dt>A pattern, which is any S-expression where atoms may be:</dt><dd><ul>
<li><p>A custom predicate of form <code class="docutils literal notranslate"><span class="pre">!&lt;pred&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">?&lt;pred&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">*&lt;pred&gt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">+&lt;pred&gt;</span></code>,
interpreted as matching exactly one expression, 0 or 1 expression,
0 or more expressions, or 1 or more expressions, respectively. Custom
predicates must be defined in eta.util.tt.preds. Some basic ones are
‘expr’, ‘atom’, and ‘lst’, being true respectively of any expression,
an atom, or a list.</p></li>
<li><p>An integer &gt;= 0, where 0, 1, 2, … respectively mean “zero or more expressions”,
“at most one expression”, “at most 2 expressions”, at most 3 expressions”, etc.</p></li>
<li><p>A dotted atom, such as <code class="docutils literal notranslate"><span class="pre">.verb</span></code> or <code class="docutils literal notranslate"><span class="pre">.branch-of-math</span></code>, i.e., starting with a dot and
denoting features of atoms, as defined by the ‘feats’ argument. These are matched
by checking whether a given expression is connected to the feature through a chain
of ‘isa’ connections.</p></li>
<li><p>Any other atom, which simply matches an identical atom in <cite>ex</cite>.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>ex</strong> (<em>s-expr</em>) – The input to match.</p></li>
<li><p><strong>feats</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a>) – A dict mapping a word w to a feature list x1, …, xk, such that
<code class="docutils literal notranslate"><span class="pre">isa(w,</span> <span class="pre">xi)</span></code> for each feature xi.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An empty list <code class="docutils literal notranslate"><span class="pre">[]</span></code> if no match, otherwise an S-expression containing the
result of the match. The result will resemble the input expression <cite>ex</cite>,
except that sequences of 0 or more constituents matched by sequence variables
will be encoded as <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">&lt;item1&gt;,</span> <span class="pre">&lt;item2&gt;,</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>s-expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.spec_function">
<span class="sig-name descname"><span class="pre">spec_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#spec_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.spec_function" title="Permalink to this definition"></a></dt>
<dd><p>Check if <cite>x</cite> is a user-defined evaluable function, i.e., if it ends with ‘!’.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.position_index">
<span class="sig-name descname"><span class="pre">position_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#position_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.position_index" title="Permalink to this definition"></a></dt>
<dd><p>Map a string denoting a position index to either an integer or list of integers (or return <code class="docutils literal notranslate"><span class="pre">[]</span></code> if not a position index).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.check_position_index_syntax">
<span class="sig-name descname"><span class="pre">check_position_index_syntax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#check_position_index_syntax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.check_position_index_syntax" title="Permalink to this definition"></a></dt>
<dd><p>Check if <cite>i</cite> is a valid position index.</p>
<dl class="simple">
<dt>A position index in tree transductions can take the following syntax:</dt><dd><ul class="simple">
<li><p>0, 1, 2, 3, …,
(equivalently, 0., 1., 2., 3., …, but NOT 0.0, 1.0, 2.0, 3.0, …)</p></li>
<li><p>or 1.1, 1.2, 1.3, …, 2.1, 2.2, 2.3, …, etc.,
(equivalently 1.1., 1.2., 1.3., …, 2.1., 2.2., 2.3., …)</p></li>
<li><p>or 1.1.1, 1.1.2, …, 1.2.1, 1.2.2, …, 2.1.1, 2.1.2, … etc.
(equivalently 1.1.1., 1.1.2., …, 1.2.1., 1.2.1., 1.2.2., … )</p></li>
</ul>
</dd>
</dl>
<p>Since trailing 0 digits are not allowed (except for standalone 0), an input
like ‘13.20’ should be given as ‘13.20.’.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="eta.util.tt.match.fill_template">
<span class="sig-name descname"><span class="pre">fill_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match_result</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/eta/util/tt/match.html#fill_template"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#eta.util.tt.match.fill_template" title="Permalink to this definition"></a></dt>
<dd><p>Fill a template containing positional indices with constituents from a match result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>template</strong> (<em>s-expr</em>) – <dl class="simple">
<dt>An S-expression containing:</dt><dd><ul>
<li><p>Positional indicators such as 3, 3.2, 3.3.2, etc., where pieces of <cite>match_result</cite> are
to be placed. E.g., here, the references are to the 3rd element of <cite>match_result</cite>,
the 2nd element of the 3rd element of <cite>match_result</cite>, etc. The index 0 is special,
as it refers to the (flattened) match result as a whole.</p></li>
<li><p>Evaluable predicates ending in ‘!’ applied to some arguments, e.g., <code class="docutils literal notranslate"><span class="pre">[lex-ulf!,</span> <span class="pre">v,</span> <span class="pre">3.2]</span></code>,
in which case the result of the predicate called on the given arguments will filled in
place. Custom predicates must be defined in <code class="docutils literal notranslate"><span class="pre">eta.util.tt.preds</span></code>, and their arguments must
match the arguments provided in <cite>template</cite>.</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>match_result</strong> (<em>s-expr</em>) – An S-expression containing sequence expressions such as <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">[a,</span> <span class="pre">b],</span> <span class="pre">c,</span> <span class="pre">[d,</span> <span class="pre">[f,</span> <span class="pre">g]]]</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The template filled in with “pieces” from match_result, as indicated by the position
indices it contains. If a position index points to a sequence, i.e., <code class="docutils literal notranslate"><span class="pre">[:seq,</span> <span class="pre">...]</span></code>, the
elements of the sequence are inserted into the result without the :seq wrapper.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>s-expr</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="eta.util.tt.choice.is_tree_root_list.html" class="btn btn-neutral float-left" title="eta.util.tt.choice.is_tree_root_list" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="eta.util.tt.match.check_position_index_syntax.html" class="btn btn-neutral float-right" title="eta.util.tt.match.check_position_index_syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Benjamin Kane.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
         .wy-nav-content { max-width: none; }
  </style>



</body>
</html>